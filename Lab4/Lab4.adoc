:imagesdir: Lab4Img
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
:toc: macro

include::Titul.adoc[lines="1..8"]
Отчет по лабораторной работе №4
include::Titul.adoc[lines="11..23"]

toc::[]

== Задание

. Написать что было изучено про порты на лекции;

. Сделать программу, которая будет переключать светодиоды на плате по алгоритму: включить 1 светодиод, задержка, 2, задержка и т.д, а затем также выключить, начиная с 1 светодиода. Выполнить основную часть программы с помощью отдельного класса.

=== Порты

Порт - это устройство для обмена данными (ввод и вывод). С помощью портов можно управлять работой других устройств. На плате есть 5 портов общего назначения, 16 линий ввода/вывода.

Порты могут работать в разных режимах:

. плавающий цифровой вход;
. цифровой вход с подтяжкой к 1;
. цифровой вход с подтяжкой к 0;​
. аналоговый;​
. цифровой выход с открытым коллектором с подтяжкой к 1 или к 0;
. цифровой двухтактный выход с подтяжкой к 1 или к 0;
. альтернативная функция с открытым коллектором с подтяжкой к 1 или к 0;
. альтернативная функция двухтактный выход с подтяжкой к 1 или к 0.

Особенности режимов:

* В цифровом режиме у порта есть 2 состояния: 1 и 0, соответственно, высокий уровень напряжения и нулевой. Когда порт настроен как цифровой вход его сопротивление бесконечно, контакт никуда не подключен, поэтому ток не протекает. +
 Любое напряжение на ножке порта будет интерпретировано как 1 или 0, в зависимости от уровня напряжения. В таком случае это называется "подвешенная" или плавающая ножка, а наводка или шум на этой ножке могут быть интерпретированы как 1 или 0 в зависимости от уровня шума. Таким образом, плавающая ножка может вызывать "дребезг" (ложные сигналы), что является недостатком данного режима.

* Чтобы убрать недостаток плавающей ножки обычно её подтягивают к 1 или 0. При подтяжке к 1 на входе всегда 1 пока не замкнут ключ. При подтяжке к 0 на входе всегда 0, пока не подано напряжение.

Регистры портов:

. GPIOx_MODER - задает режимы работы индивидуально каждого из вывода порта;
. GPIOx_OSPEEDR - задает скорость работы порта;
. GPIOx_PUPDR - задает подключение подтягивающих резисторов;
. GPIOx_IDR - регистр входных данных, из которого считывается состояние входов порта;
. GPIOx_ODR - регистр выходных данных;
. GPIOx_OTYPER - в режиме выхода или альтернативной функции, соответствующий бит регистра устанавливает тип выхода;
. GPIOx_BSRR - это регистр побитовой установки/сброса данных на выходных линиях порта;
. GPIOxLCKR - регистр, позволяющий защитить текущую настройку конфигурации.

=== Гирлянда

Листинг pin.h
[source, cpp, linenums]
----
#ifndef PIN
#define PIN

#include "gpiocregisters.hpp" // for GPIOC
#include "gpioaregisters.hpp" // for GPIOA

template<typename Port, int pinNumber>
class Pin
{
public:
  void Toggle()
  {
    Port::ODR::Toggle(1 << pinNumber) ;
  }
} ;

#endif

#ifndef GarLand
#define GarLand

template<auto& pin1,auto& pin2,auto& pin3,auto& pin4, int& time>
class Garland
{
public:
    void delay(int cycles)
    {
      for(int i = 0; i < cycles; ++i)
      {
        asm volatile("");
      }
    }
    void Switch()
    {
      pin1.Toggle();
      delay(time);
      pin2.Toggle();
      delay(time);
      pin3.Toggle();
      delay(time);
      pin4.Toggle();
      delay(time);
    }
};

#endif
----

Листинг main.cpp
[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "pin.h"
#include "gpiocregisters.hpp" // for GPIOC

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
  int __low_level_init(void)
  {
  }
}

Pin<GPIOA,5> pin1 ;
Pin<GPIOC,9> pin2 ;
Pin<GPIOC,8> pin3 ;
Pin<GPIOC,5> pin4 ;
int time = 2500000 ;
Garland<pin1,pin2,pin3,pin4,time> garland;

int main()
{
  
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ; // установить порт А.5 на выход
  //Светодиоды на портах C.5,C.8, C.9 на выход
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  for(;;)
  {
    // Гирлянда: зажечь 1 светодиод, задержка, 2, задержка и т.д. И потом также гасить
    garland.Switch() ;
  }
  
  return 1;
}
----

На видео представлена работа программы.

.Видео - Демонстрация "гирлянды"
video::Video.mp4[opts="muted"]

== Вывод по работе

В ходе данной работы было проведено ознакомление с портами и их режимами работы. Была написана программа, которая переключала светодиоды по заданному алгоритму.