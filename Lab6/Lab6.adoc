:imagesdir: Lab6Media
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
:toc: macro

include::Titul.adoc[lines="1..8"]
Отчет по лабораторной работе №6
include::Titul.adoc[lines="11..23"]

toc::[]

== Задание

Сделать программу "Гирлянда", которая будет работать со светодиодами в 3 режимах:

. все светодиоды мигают;
. елочка;
. шахматы.

Переключение между режимами должно производиться нажатием на кнопку USER.

=== Гирлянда

UML диаграмма программы представлена на рисунке.

[#Диаграмма]
.UML диаграмма
image::Figure.png[]

Листинг pin.h
[source, cpp, linenums]
----
#ifndef PIN
#define PIN
#include "ipin.h" // for IPin
template<typename Port, int pinNumber>
class Pin : public IPin
{
public:
  void Toggle() const override
  {
    Port::ODR::Toggle(1 << pinNumber) ;
  }
} ;
#endif
----

Листинг ipin.h
[source, cpp, linenums]
----
#ifndef IPIN
#define IPIN
class IPin
{
public:
  virtual void Toggle() const = 0; 
};
#endif
----

Листинг imode.h
[source, cpp, linenums]
----
#ifndef IMODE
#define IMODE

class IMode
{
public:
  virtual void Update() = 0;
};

class IModeDefaultSetter // очистка светодиодов
{
public:
  virtual void Clear() = 0;
};

#endif
----

Листинг allflickmode.h
[source, cpp, linenums]
----
#ifndef ALLFLICKMODE
#define ALLFLICKMODE

#include "imode.h" // for IMode
#include <array>

template<auto&...pins>
class AllFlickMode : public IMode, public IModeDefaultSetter
{
public:
  void Clear() override
  {
    *reinterpret_cast<uint32_t*>(0x40020814) = 0;
    *reinterpret_cast<uint32_t*>(0x40020014) = 0;
  }
  void Update() override
  {
    for(std::size_t i=0; i < leds.size();i++){
    leds[i]->Toggle();
    }
  }
private:
  std::array<IPin*, sizeof ...(pins)> leds = {&pins...};
};

#endif
----

Листинг treemode.h
[source, cpp, linenums]
----
#ifndef TREEMODE
#define TREEMODE

#include "imode.h" // for IMode
#include <array>

template<auto&...pins>
class TreeMode : public IMode, public IModeDefaultSetter
{
public:
  void Clear() override
  {
    *reinterpret_cast<uint32_t*>(0x40020814) = 0;
    *reinterpret_cast<uint32_t*>(0x40020014) = 0;
  }
  void Update() override
  {
    // код для елочки
    leds[i++]->Toggle();
    if(i == leds.size())
    {
      i = 0;
    }
  }
private:
  std::size_t i = 0;
  std::array<IPin*, sizeof ...(pins)> leds = {&pins...};
};

#endif
----

Листинг chessmode.h
[source, cpp, linenums]
----
#ifndef CHESSMODE
#define CHESSMODE

#include "imode.h" // for IMode
#include <array>

template<auto&...pins>
class ChessMode : public IMode, public IModeDefaultSetter
{
private:
  bool flag = true; // для переключения с нечетных на четные (если true, то нечетные)
public:
  void Clear() override
  {
    flag = true;
    *reinterpret_cast<uint32_t*>(0x40020814) = 0;
    *reinterpret_cast<uint32_t*>(0x40020014) = 0;
  }
  void Update() override
  {
    // шахматный порядок
    if(flag) // нечетные
    {
      for(std::size_t i = 0; i < leds.size(); i+=2)
      {
        leds[i]->Toggle();
      }
    } else // четные
    {
      for(auto it: leds)
      {
        it->Toggle();
      }
    }
    flag = false;
  }
private:
  std::array<IPin*, sizeof ...(pins)> leds = {&pins...};
};

#endif
----

Листинг ibutton.h
[source, cpp, linenums]
----
#ifndef IBUTTON
#define IBUTTON

class IButton
{
public:
  virtual bool IsPressed() = 0; 
};

#endif
----

Листинг button.h
[source, cpp, linenums]
----
#ifndef BUTTON
#define BUTTON

#include <ibutton.h> // for IButton

template<typename Port, int pinNumber>
class Button : public IButton
{
public:
  bool IsPressed() override // проверка нажатия кнопки
  {
    bool press = false; // нажатие (если false, то нажатия нет)
    if((Port::IDR::Get()&(1 << pinNumber))!=(1 << pinNumber))
    {
    press = true;
    }
    return press;
  }
};

#endif
----

Листинг garland.h
[source, cpp, linenums]
----
#ifndef GARLAND
#define GARLAND

#include "imode.h" // for IMode
#include <array>

template<auto& ...presets>
class Garland : public IMode
{
public:
  void NextMode()
  {
    pCurrentMode = mod[i];
    i++;
    if(i == mod.size())
    {
      i = 0;
    }
  }
  void Update() override
  {
    pCurrentMode->Update();
  }
private:
  std::size_t i = 0;
  std::array<IMode*, sizeof ...(presets)> mod = {&presets...};
  IMode* pCurrentMode = mod[0];
};
#endif
----

Листинг main.cpp
[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "pin.h" // for LED toggle
#include "button.h" // for reсord button push 
#include "gpiocregisters.hpp" // for GPIOC
#include "treemode.h" // for TreeMode
#include "chessmode.h" // for ChessMode
#include "allflickmode.h" // for AllFlickMode
#include "garland.h" // for Garland work

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)
  {
    asm volatile("");
  }
}

Pin<GPIOA,5> pin1 ;
Pin<GPIOC,9> pin2 ;
Pin<GPIOC,8> pin3 ;
Pin<GPIOC,5> pin4 ;
TreeMode<pin1, pin2, pin3, pin4> treeMode;
ChessMode<pin1, pin2, pin3, pin4> chessMode;
AllFlickMode<pin1, pin2, pin3, pin4> allflickMode;
Garland<allflickMode, treeMode, chessMode> garland; // порядок режимов в гирлянде
Button<GPIOC, 13> button; // кнопка USER

int main()
{
  GPIOC::MODER::MODER13::Input::Set() ; // установка порта C.13 кнопки на вход
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ; // установить порт А.5 на выход
  //Светодиоды на портах C.5,C.8, C.9 на выход
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  for(;;)
  {
    if(button.IsPressed())
    {
    treeMode.Clear(); //
    chessMode.Clear(); // очистка всех режимов, чтобы светодиоды не сбивались
    allflickMode.Clear(); // 
    garland.NextMode(); // следующий режим
    }
    garland.Update();
    delay(2500000);
  }
  
  return 1;
}
----

На видео представлена работа программы.

.Видео - Демонстрация работы гирлянды
video::Video.mp4[opts="muted,loop"]

== Вывод по работе

В ходе данной работы была написана программа, которая работает в режиме гирлянды с переключением 3 режимов по нажатию кнопки.