:imagesdir: Lab3Img
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
:toc: macro

include::Titul.adoc[lines="1..8"]
Отчет по лабораторной работе №3
include::Titul.adoc[lines="11..23"]

toc::[]

== Задание

. Написать что нового было изучено на лекции;

. Сделать фазовую подстройку частоты (PLL, ФАПЧ). ФАПЧ должен тактироваться на частоте 32 МГц от внутреннего высокочастотного генератора (HSI) 16 МГц.

=== Операторы

Существует виды: 

* арифметические операторы;
* операторы сравнения;
* логические операторы;
* побитовые операторы;
* составное присваивание;
* операторы работы с указателями и членами класса;
* функторы, тернарные операции, sizeof(), запятая, приведение типа, new.

Новый для изучения оператор: запятая.

Оператор "запятая" используется для связки нескольких выражений. Левая сторона оператора "запятая" всегда вычисляется первой, а далее правая часть. Оператор "запятая" вызывает выполнение последовательности действий. Когда он используется с правой стороны оператора присваивания, то присваиваться будет значение последнего выражения, стоящего в разделенном запятыми списке.

Например:
[source, cpp, linenums]
----
int main()
{
  int x, y ;
  x = (y = 2, y + 1) ;
  printf("%d", x) ;
  return 1 ;
}
----

В данном примере сначала присваивается 2 переменной у, а затем 3 переменной х. Скобки необходимы, поскольку оператор "запятая" имеет более низкий приоритет по сравнению с оператором присваивания.

А также оператор "запятая" может быть использован при создании ряда template (шаблона). В таком случае запятая будет стоять в скобках в команде вызова какого-либо числа заданных функций. Таким образом, "запятая" может значительно упростить код.

=== Фазовая подстройка частоты (ФАПЧ)

В используемом микроконтроллере STM32F411 есть система тактирования (рисунок 1) и, соответственно, модуль тактирования.

[#Система_тактирования]
.Диаграмма системы тактирования
image::Figure1.png[]

Для формирования системной тактовой частоты SYSCLK могут использоваться 3 основных источника:​

* HSI (high-speed internal) — внутренний высокочастотный RC-генератор;
* HSE (high-speed external) — внешний высокочастотный генератор;​
* PLL — система ФАПЧ; набор из умножителей и делителей, в котором исходный сигнал получается от HSI или HSE, а на выходе у него уже другая частота.

Включение и выключение основных генераторов (источников) производится через регистр RCC_CR — Clock Control register. 

С помощью регистров PLLM, PLLN, PLLP можно подобрать любую частоту до 100 Мгц включительно по формуле:​
====
   f = f(PLL clock input) × (PLLN / PLLM) /PLLP​
====

Регистр имеет поля различной длины PLLM (2 ≤ PLLM ≤ 63), PLLN ( 50 ≤ PLLN ≤ 432), PLLP (PLLP = 2, 4, 6, или 8).

Чтобы включить PLL нужно установить 24 бит (PLLON). Этот бит устанавливается и скидывается программно, чтобы включить PLL. Бит не может быть скинут, если PLL уже используется как системная частота. ​Сразу после установки частоты, нужно проверить, что частота с нового источника стабилизировалась. Для этого используются те же поля того же регистра CR, оканчивающиеся на RDY (Ready). Для PLL это бит 25 (PLLRDY).

В нашей задаче необходимо добиться частоты 32 МГц с помощью ФАПЧ. Изначально код имеет вид, как в лабораторной работе №2, при этом частота тактирования равна 16 МГц (используется источник HSI). Частичный листинг кода из ЛР №2:
[source, cpp, linenums]
----
extern "C"
{
int __low_level_init(void)
{
  //Switch on external 16 MHz oscillator
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {
  }
  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  return 1;
}
}
----

После увеличения частоты в 2 раза светодиод должен мигать в 2 раза чаще.

Используя формулу для расчета частоты, нужно подобрать только соответствующие коэффициенты. Возьмем коэффициенты: PLLN = 64, PLLM = 16, PLLP = 2. Подставим коэффициенты в формулу:
====
   f = (16'000'000 × (64 / 16)) / 2 = (16'000'000 × 4) / 2 = 32'000'000 Гц = 32 МГц
====

Тогда код программы примет вид:
[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C"
{
  int __low_level_init(void)
  {
    // Switch on HSI
    RCC::CR::HSION::On::Set();    
    while (RCC::CR::HSIRDY::NotReady::IsSet())
    {      
    }
    // Switch on PLL
    RCC::CR::PLLON::On::Set();
    // All PLL to 0
    *reinterpret_cast<std::uint32_t*>(0x40023804) &= 0;
    // PLL with HSI source
    RCC::PLLCFGR::PLLSRC::HsiSource::Set();
    // PLLP = 2
    RCC::PLLCFGR::PLLP0::Pllp2::Set();
    // PLLM = 16
    *reinterpret_cast<std::uint32_t*>(0x40023804) |= (1U << 4U);
    // PLLN = 64
    *reinterpret_cast<std::uint32_t*>(0x40023804) |= (1U << 12U);
    while (RCC::CR::PLLRDY::Unclocked::IsSet())
    {      
    }
    // PLL on SW
    RCC::CFGR::SW::Pll::Set();
    while (!RCC::CFGR::SWS::Pll::IsSet())
    {      
    }
    RCC::APB2ENR::SYSCFGEN::Enable::Set();   
    return 1;
  }
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)
  {
    asm volatile("");
  }
}

int main()
{
  
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  
  GPIOA::MODER::MODER5::Output::Set() ;
  
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;

  GPIOC::ODR::ODR8::High::Set();
  std::uint32_t* ptrC = reinterpret_cast<std::uint32_t*>(0x40020814) ; // регистр GPIOC
  for(;;)
  {
     *ptrC |= (1U << 5U); 
     delay(1000000);
     *ptrC &= ~(1U << 5U);
     delay(1000000);
  }

  return 1;
}
----

На видео представлена работа программы.

.Видео - Демонстрация мигания светодиода с частотой тактирования 32 МГц
video::Video.mp4[opts="muted"]

== Вывод по работе

В ходе данной работы было проведено ознакомление с новым оператором "запятая". Была написана программа, в которой была использована система ФАПЧ для получения частоты тактирования 32 МГц.