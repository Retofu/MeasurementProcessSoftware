:imagesdir: Report2Img
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
:toc: macro

[.text-center]
Министерство науки и высшего образования Российской Федерации Федеральное государственное образовательное учреждение высшего образования
«Южно-Уральский государственный университет» (Национальный исследовательский университет) +
Высшая школа электроники и компьютерных наук +
Кафедра «Информационно-измерительная техника» +
 +
дисциплина: 1.Ф.П1.06 (Программное обеспечение измерительных процессов) +
 +
Отчет №2 +
на тему "Типы данных C++" 

[.text-right]
Работу принял, доцент +
/ С.В. Колодий / +
2023 г. +
 +
Автор работы +
студент группы КЭ-413 +
/ А.И. Кривоносов / +
2023 г.

[.text-center]
Челябинск 2023

toc::[]

== Задание

. Написать какая информация про типы данных была новой для студента.

Типы данных, используемые в C++, представлены на рисунке 1.

[#Типы данных]
.Типы данных в C++
image::Figure1.png[]

Данные делятся на простые (целые и с плавающей точкой), структурированные и адресные.

Размеры типов определены не четко, для них существует правило:
[.source, cpp]
----
1             <= sizeof(char)     <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----

Поэтому, например, вместо прямых типов int практичнее использовать псевдонимы:
[horizontal]
std::uint32_t:: целое беззнаковое длиной 32 бита
std::int64_t::  целое знаковое длинной 64 бита
std::uint8_t:: целое знаковое длинной 8 бит

Таким образом, переменная uint32_t на любой платформе будет беззнаковая целая с длиной 32 бита. Также есть возможность определять свой пользовательский тип и создавать псевдоним типа.

В C++ различают явное и неявное преобразование типов данных. Неявное преобразование типов данных выполняет компилятор, а явное преобразование - программист.

Неявное преобразование типа может быть осуществлено с помощью литерала при объявлении переменной. Однако рекомендуется использовать явное преобразование, чтобы однозначно понимать какой тип данных должен получиться после преобразования.

Существует 4 варианта явного преобразования:

* static_cast - позволяет сделать приведение близких типов (целые, пользовательских типов которые могут создаваться из типов который приводится, и указатель на void* к указателю на любой тип).

Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки;

* const_cast;
* dynamic_cast;
* reinterpret_cast - преобразует типы, несовместимые друг с другом, и используется для преобразования:

** в свой собственный тип;
** указателя в интегральный тип;
** интегрального типа в указатель;
** указателя одного типа в указатель другого типа;
** указателя на функцию одного типа в указатель на функцию другого типа.

== Вывод

Была получена новая информация по типам данных C++, псевдонимам, а также по явному и неявному преобразованиям типов данных.