:imagesdir: Lab1Img
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
:toc: macro

[.text-center]
Министерство науки и высшего образования Российской Федерации Федеральное государственное образовательное учреждение высшего образования
«Южно-Уральский государственный университет» (Национальный исследовательский университет)

[.text-center]
Высшая школа электроники и компьютерных наук Кафедра «Информационно-измерительная техника»

[.text-center]
дисциплина: 1.Ф.П1.06 (Программное обеспечение измерительных процессов)

[.text-center]
Отчет по лабораторной работе №1

[.text-right]
Работу принял, доцент +
___/ С.В. Колодий / +
___2023 г.

[.text-right]
Автор работы +
студент группы КЭ-413 +
___/ А.И. Кривоносов / +
___2023 г.

[.text-center]
Челябинск 2023

toc::[]

== Задание 1

. Создать проект C++ c main.cpp
. Подключить к проекту файл cstartup.cpp
. Создать папки AbstractHardware/Registers/FiledValues, Common, Application, FreeRtos
. Создать структуру проекта в соотвествии со структурой папок
. Настроить STACK, HEAP
. Скопировать содержимое папки Registers и Common с проекта преподавателя в свою папку
. Написать программу в main.cpp

* После создания проекта и настройки структуры проекта (выполнено во время практического занятия) финальная структура проекта принимает вид, представленный на рисунке 1.

[#Финальная_структура]
.Финальная структура проекта
image::Figure1.png[]

* Далее необходимо настроить стек (STACK) и кучу (HEAP).

Обычно размер стека вычисляется экспериментально и задается с небольшим запасом. Но также существуют правила задания размера стека:

. принято считать, что все локальные переменные создаются на стеке (хотя часть из них могут быть созданы и на регистрах);

. есть 16 регистров + регистры блока с плавающей точкой, которые должны быть сохранены на стеке;

. каждая вложенная подпрограмма должна сохранить на стеке все данные из пункта 1 и 2. То есть если вложенность будет 2, то и сохранять придется примерно в два раза больше данных;

. каждое прерывание должно сохранить данные из пункта 1 и 2.

Чтобы задать размер стека и кучи, нужно нажав на правую кнопку мыши на проекте, выбрать Option⇒Linker и нажать кнопку Edit, далее выбрать закладку Stack/Heap Size (рисунок 2).

[#Размер стека и кучи]
.Установка размера стека и кучи
image::Figure2.png[]

* В main.cpp была написана программа для включения светодиода
[source, cpp, linenums]

----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C"
{
int __low_level_init(void)
{
}
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)    
  {   
    asm volatile("");
  }    
}

int main()
{  
  //Подать тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт C
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Порт A.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порта C.5, C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  for(;;)
  {
   
     GPIOA::ODR::ODR5::High::Set();
     GPIOC::ODR::ODR5::High::Set();
     delay(1000000); 
     GPIOA::ODR::ODR5::Low::Set();
     GPIOC::ODR::ODR5::Low::Set();
     delay(1000000); 
  }
  
  return 1;
}
----

== Задание 2

. Откомпилировать и отлинковать программу
. Загрузить программу в симуляторе
. Сделать пошаговую отладку
. Настроить Debugger на отладку через StLink
. Подключить плату к компьютеру
. Загрузить программу в плату
. Выполнить пошаговую отладку
. Описать полученный результат

* Компиляция программы представлена на рисунке 3.

[#Компиляция]
.Компиляция программы
image::Figure3.png[]

* Загрузка программы на симуляторе представлена на рисунке 4.

[#Загрузка программы на симуляторе]
.Загрузка программы на симуляторе
image::Figure4.png[]

* Настройка дебаггера на отладку через ST-LINK представлена на рисунке 5.

[#Дебаггер через ST-LINK]
.Отладка через ST-LINK
image::Figure5.png[]

* После загрузки программы в плату и её запуска на плате начали попеременно мигать светодиоды.

== Задание 3

. Запустить анализатор стека. Узнать рекомендуемый размер стека.
. Изменить в проекте размер стека на рекомендуемый
. Создать map файл
. Описать что написано в map файле
. Поставить размер кучи HEAP в 0. Объяснить почему так можно сделать. И почему STACK нельзя

* Так как в настройках линкера выбрана опция "Generate linker map file", после компиляции и сборки программы в Output появляется файл с расширением .map (рисунок 6). В данном файле можно узнать адреса объектов, их размер, тип и местонахождение.

** В нём можно увидеть, что таблица векторов прерываний размером 0x198 находится в сегменте .intvec по адресу от 0x800'0000 до 0x800'0198.

** Например, в сегменте .rodata находится константа размером 1 байт с адресом 0x800'0266.

** Стек с заданным размером 0x100 в сегменте CSTACK находится по адресу от 0x2000'0000 до 0x2000'0100.

[#Map файл]
.Содержание файла iarproject.map
image::Figure6.png[]

* Размер кучи HEAP возможно поставить в 0 (рисунок 2) без потери работоспособности программы, так как куча используется только для динамически выделяемой памяти, то есть с помощью оператора new. Динамическое выделение памяти не рекомендуется для использования при создании надежного ПО. +
В отличие от HEAP, стек нельзя задавать равным 0, потому что на стеке хранятся все локальные переменные, там сохранены регистры, а также он используется при прерывании, чтобы вернуться обратно в программу, восстановив все переменные и контекст.

== Вывод по работе

В ходе данной работы было проведено ознакомление со средой разработки IAR Workbench for ARM и рассмотрены основные функции программы. Была создана программа для микроконтроллера, а также была рассмотрена структура и организация памяти.