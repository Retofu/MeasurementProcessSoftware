:imagesdir: Lab9Img
:figure-caption: Рисунок
:table-caption: Таблица
:toc-title: Оглавление
:toc: macro

include::Titul.adoc[lines="1..8"]
Отчет по лабораторной работе №9
include::Titul.adoc[lines="11..23"]

toc::[]

== Задание

. Дописать программу, которая будет переключать все светодиоды с периодом 0,5 секунды. По нажатию кнопки увеличивать период моргания на 0,1 секунды. При достижении периода 1 секунда сбрасывать до 0,5 секунды. Для задания периода использовать таймер TIM2 (для данного варианта), а прерывания для кнопки сделать через TIM5.

=== Программа

В startupF411RE.cpp были добавлены строчки:
[source, cpp, linenums]
----
#include "timersconfig.h" // for Timers Configuration
----
и
[source, cpp, linenums]
----
tTimer2::handler,           //TIM2 
tTimer5::handler,	        //TIM5 global interrupt
----

Листинг main.cpp
[source, cpp, linenums]
----
#include "rccregisters.hpp" // for RCC
#include "tim2registers.hpp" // for TIM2
#include "tim5registers.hpp" // for TIM5
#include "nvicregisters.hpp" // for NVIC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC
#include "pin.h" // for LED toggle
#include "button.h" // for reсord button push 
#include "allflickmode.h" // for AllFlickMode
#include "stkregisters.hpp" // for STK
#include "scbregisters.hpp" // for ICSR

using tMsec = std::uint32_t;
tMsec period = 500U;

extern "C"
{
  int __low_level_init(void)
  {
    RCC::APB1ENR::TIM2EN::Enable::Set();
    RCC::APB1ENR::TIM5EN::Enable::Set();

    NVIC::ISER0::Write(1 << 28U); // разрешили глобальное прерывание для TIM2
      
    TIM2::PSC::Write(15999U);
    TIM2::CR1::URS::OverflowEvent::Set();
    TIM2::ARR::Write(500U);
    TIM2::SR::UIF::Set(0);
    TIM2::CNT::Write(0);
    TIM2::DIER::UIE::Enable::Set(); // разрешили прерывание по переполнению
    
    NVIC::ISER1::Write(1 << 18U); // разрешили глобальное прерывание для TIM5
    
    TIM5::PSC::Write(15999U);
    TIM5::CR1::URS::Value1::Set();
    TIM5::ARR::Write(100U);
    TIM5::SR::UIF::Set(0);
    TIM5::CNT::Write(0);
    TIM5::DIER::UIE::Value1::Set(); // разрешили прерывание по переполнению
    return 1;
  }
}

void ReloadTimerPeriod(tMsec period)
{
  TIM2::ARR::Write(period);
}

Pin<GPIOA,5> pin1 ;
Pin<GPIOC,9> pin2 ;
Pin<GPIOC,8> pin3 ;
Pin<GPIOC,5> pin4 ;
AllFlickMode<pin1, pin2, pin3, pin4> allflickMode;
Button<GPIOC, 13> button;

int main()
{
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOC::MODER::MODER13::Input::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ; // установить порт А.5 на выход
  //Светодиоды на портах C.5,C.8, C.9 на выход
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  TIM2::CR1::CEN::Enable::Set();
  TIM5::CR1::CEN::Enable::Set();
  
  for(;;)
  {
    if(allflickMode.CheckForUpdate())
    {
      allflickMode.Update();
      allflickMode.SetFlag(false);
    }
    if(button.CheckForUpdate())
    {
      period = (period < tMsec(1000)) ? (period + tMsec(100U)) : tMsec(500U);
      button.SetFlag(false);
      ReloadTimerPeriod(period);
    }
  }
  
  return 1;
}
----

Листинг timersconfig.h
[source, cpp, linenums]
----
#ifndef TIMERSCONFIG
#define TIMERSCONFIG

#include "pin.h" // for pin.h
#include "allflickmode.h" // for AllFlickMode
#include "gpiocregisters.hpp" // for GPIOC
#include "gpioaregisters.hpp" // for GPIOA
#include "tim2registers.hpp" // for TIM2 registers
#include "timer2.h" // for Timer2
#include "button.h" // for button
#include "tim5registers.hpp" // for TIM5 registers
#include "timer5.h" // for Timer5

extern Pin<GPIOA,5> pin1 ;
extern Pin<GPIOC,9> pin2 ;
extern Pin<GPIOC,8> pin3 ;
extern Pin<GPIOC,5> pin4 ;

extern Button<GPIOC, 13> button;
extern AllFlickMode<pin1, pin2, pin3, pin4> allflickMode; 

using tTimer2 = Timer2<allflickMode>;
using tTimer5 = Timer5<button>;

#endif
----

Листинг timer2.h
[source, cpp, linenums]
----
#ifndef TIMER2
#define TIMER2

#include "tim2registers.hpp" // for TIM2

template <auto& allflickMode>
class Timer2
{
public:
  static void handler()
  {
    if(TIM2::SR::UIF::Get() == 1 and TIM2::DIER::UIE::Enable::IsSet())
    {
      allflickMode.SetFlag(true);
      TIM2::SR::UIF::Set(0);
    }
  }
};

#endif
----

Листинг timer5.h
[source, cpp, linenums]
----
#ifndef TIMER5
#define TIMER5

#include "tim5registers.hpp" // for TIM5

template <auto& button>
class Timer5
{
public:
  static void handler()
  {
    if(TIM5::SR::UIF::InterruptPending::IsSet() and TIM5::DIER::UIE::Value1::IsSet())
    {
      if(button.IsPressed())
      {
        button.SetFlag(true);
      }
      TIM5::SR::UIF::NoInterruptPending::Set();      
    }
  }
};

#endif
----

Листинг button.h
[source, cpp, linenums]
----
#ifndef BUTTON
#define BUTTON

#include <ibutton.h> // for IButton
#include <array> // for array

template<typename Port, int pinNumber>
class Button : public IButton
{
public:
  bool IsPressed() override
  {
    if(((Port::IDR::Get() & (1 << pinNumber)) == 0) && (isSet))
    {
      isSet = false;
    } else if(((Port::IDR::Get() & (1 << pinNumber)) == (1 << pinNumber)) && (!isSet))
    {
      isSet = true;
      return true;
    }
    return 0;
  }
  bool CheckForUpdate()
  {
    return InterruptionFlag;
  }
  bool SetFlag(bool flag)
  {
    InterruptionFlag = flag;
  }
private:
  bool InterruptionFlag = false;
  bool isSet = true;
};

#endif
----

Листинг allflickmode.h
[source, cpp, linenums]
----
#ifndef ALLFLICKMODE
#define ALLFLICKMODE

#include "imode.h" // for IMode
#include <array>

template<auto&...pins>
class AllFlickMode : public IMode
{
public:
  void Update() override
  {
    for(auto it: leds)
    {
      it->Toggle();
    }
  }
  void SetToDefault() override
  {
    for(auto it: leds)
    {
      it->Off();
    }
  }
  bool CheckForUpdate()
  {
    return InterruptionFlag;
  }
  bool SetFlag(bool flag)
  {
    InterruptionFlag = flag;
  }
private:
  std::array<IPin*, sizeof ...(pins)> leds = {&pins...};
  bool InterruptionFlag = false;
};

#endif
----

На видео представлена работа программы.

.Видео - Демонстрация работы программы
video::Video.mp4[opts="muted"]

== Вывод по работе

В ходе данной работы была написана программа, которая переключает светодиоды по заданному алгоритму с использованием таймеров и прерываний.